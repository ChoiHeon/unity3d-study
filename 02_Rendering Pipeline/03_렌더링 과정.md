# 렌더링 과정

### GPU

* 그래픽 처리를 위한 칩셋이 이루어집니다.
* CPU의 명령을 받아서 렌더링을 수행합니다.

### VRAM 

* Video Random Access Memory의 약자
* GPU에 있는 메모리입니다.
* 텍스쳐, 메시 데이터와 같은 렌더링에 필요한 데이터, 렌더링 결과를 저장하는 버퍼들이 포함됩니다.
* 렌더링 수행시 VRAM을 참고해서 그래픽을 처리합니다.

### 유니티의 렌더링 과정

1. 게임이 실행되면 저장장치에 있는 Mesh을 불러와 렌더링할 것을 요구합니다.

2. 파일 형태였던 Mesh를 RAM으로 로드하는 과정에서 메쉬 정보로 바뀝니다.

   * 메쉬 정보는 vertex의 위치과 정보 등 입니다.

3. CPU와 GPU의 상호작용이 일어납니다.

   * 커맨드 버퍼 (또는 Ring Buffer)로 불리는 큐를 사용해서 상호작용합니다.

4. CPU가 GPU에게 렌더링 명령을 내립니다. 

   * 명령은 2단계로 이루어집니다.

   1. Render State를 설정합니다.
      * Render State는 Vertex Shader, Pixel Shader, Texture, Lighting Setting을 포함합니다.
      * 이전에 작업한 Render State와 동일하다면 다음 명령으로 넘어갑니다.
      * Remder State를 설정하는 작업은 드로우 콜보다 비용이 큽니다.
      * 따라서 배칭(Batching)이 필요합니다. 
      * 유니티는 동일한 셰이더, 머터리얼, 텍스쳐 등을 사용하는 것을 하나로 묶어서 관리합니다.
   2. Mesh를 그리라는 명령을 내립니다. (드로우 콜 / Draw Call)
      * 그동안 RAM에서 VRAM으로 메쉬 정보를 전달합니다.

5. 드로우 콜이 끝나면 GPU가 Mesh를 그립니다.

6. Vertax Shader가 실행됩니다.

   * 메쉬 정보(속성)를 읽습니다.
   * 정점이 어디에 위치해야 하는지, 빛의 방향과 세기 등을 계산합니다.
   * 읽은 정보를 world space -> view space -> projection space로 전환합니다.

7. Culling (선택적 단계)

   * 면 관련 작업입니다.
   * 앞면 또는 뒷면을 그릴지를 선택합니다. (둘 모두 가능)
   * 정점을 시계방향으로 그리면 앞면, 반시계방향이면 뒷면을 그립니다. => 삼각형

8. Rasterizer 실행

   * 어떤 픽셀들을 스크린에 그릴지를 결정합니다.
   * 따라서 픽셀 수만큼 실행됩니다.
   * projection space로 전환한 이유입니다.

9. Pixel Shader (= Fragment Shader)

   * 각 픽셀에 대해서 어떤 색인지를 계산합니다.

   * 최종 픽셀의 색에 영향을 주는 pixel color, pixel albedo, pixel z-depth를 얻을 수 있습니다.

10. Z Test

    * 100개의 픽셀이 있다면 100 크기의 Color Buffer와 Z Buffer가 있습니다.
    * Color Buffer에는 각 픽셀의 색이, Z Buffer에는 z-depth가 저장됩니다.
    * 각 픽셀에 대해 Pass / Fail을 결정합니다.
    * 임의의 픽셀이 다른 픽셀 뒤에 있는지 판단해서 뒤에 있다면 폐기합니다. 

11. Blending 발생 (선택적 단계)

    * 투명, 반투명 픽셀에 대한 단계입니다.
    * 반투명 오브젝트가 불투명 오브젝트 앞에 올 때 어떻게 처리할 지를 결정합니다.

12. Stecil Test 실행 (선택적 단계)

    * 특정 부분만 보여지고 싶을 때 실행합니다.
    * stencil 값이 일치하는 픽셀 위치에만 그립니다.

13. ColorMask 실행
    * RGBA 채널 값을 거부하거나 분리할 수 있습니다.
    * 만약 `ColorMaxk RG`로 실행하면 RG 채널 값만 보여지게 됩니다.
14. 최종 컬러 지정
    * 최종 컬러를 Color Buffer에 넣고 스크린에 그립니다.

15. 이후부턴 프레임마다 오브젝트의 위치와 모습 등 물리적인 요소들이 결정되는 업데이트 함수들이 끝난 후에 렌더링을 수행합니다.



